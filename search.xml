<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cron 表达式学习</title>
    <url>/2022/07/12/cron-study/</url>
    <content><![CDATA[<p>之前在做一些定时处理的时候经常接触到了Cron表达式，但每次都是泛泛的了解了下，最近又有了定时任务相关的一些需求和想法，因此这里尝试系统的学习和了解一下 <span id="more"></span></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Required</th>
<th>Allowed Values</th>
<th>Allowed Special Characters</th>
</tr>
</thead>
<tbody><tr>
<td>Seconds</td>
<td>Y</td>
<td>0-59</td>
<td>, - * &#x2F;</td>
</tr>
<tr>
<td>Minutes</td>
<td>Y</td>
<td>0-59</td>
<td>, - * &#x2F;</td>
</tr>
<tr>
<td>Hours</td>
<td>Y</td>
<td>0-23</td>
<td>, - * &#x2F;</td>
</tr>
<tr>
<td>Day of month</td>
<td>Y</td>
<td>1-31</td>
<td>, - * ? &#x2F; L W</td>
</tr>
<tr>
<td>Month</td>
<td>Y</td>
<td>0-11 or JAN-DEC</td>
<td>, - * &#x2F;</td>
</tr>
<tr>
<td>Day of week</td>
<td>Y</td>
<td>1-7 or SUN-SAT</td>
<td>, - * ? &#x2F; L #</td>
</tr>
<tr>
<td>Year</td>
<td>N</td>
<td>empty or 1970-2099</td>
<td>, - * &#x2F;</td>
</tr>
</tbody></table>
<h2 id="和"><a href="#和" class="headerlink" title="* 和 ?"></a>* 和 ?</h2><p>这里值得一提的是 * 和 ? 的区别</p>
<p>*: 很好理解，代表所有的，例如所有时刻的每一秒就是 <code>* * * * * ? </code> </p>
<p>?: 代表不受控制的，只能由 Day of week 和 Day of month使用，因为二者是互斥的，例如：</p>
<p>当你指定 Day of week 为周 1 时，对应的 Day of month 是 ?, 随意几号<br>当你指定 Day of month 为每月 1 号时，对应的Day of week 就需要为 ?, 随意周几</p>
<h2 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h2><p>Day of week里 0代指的是周日</p>
<h2 id="特殊字符含义"><a href="#特殊字符含义" class="headerlink" title="特殊字符含义"></a>特殊字符含义</h2><p>为了方便，都用数字来表示。</p>
<ol>
<li>,: 可以理解为一个数组， 例如 1,3,10 * * * * ? 代表每分钟的第 1 秒、第 3 秒、第 10 秒执行</li>
<li>-: 表示连续的范围，可以理解为数组的简写 1-6 对应的数组完全体写法就是 1,2,3,4,5,6</li>
<li>*: 匹配所有值，对于秒就是 0-59 ，对于月就是 0-11</li>
<li>?: 无法控制的，也不需要在意的，例如当我在意的是每周1，我就无法在意或控制周一对应的是每月的1号</li>
<li>&#x2F;: 表示step,例如在 Day of month 上 x&#x2F;y 完整形式可以写成x-31&#x2F;y (有的月份30天，有的31天，可能不一样。以此类推，如果是在秒上，就是 x-59&#x2F;y) ，表示的意思就是从 每月x号开始一直到31号，每隔y天执行一次</li>
<li>L: 表示最后的,只能在 Day of month 和Day of week 上使用，在Day of month 上表示每月的最后一天（闰年的2月最后一天是28号），在 Day of week 上表示每周的最后一个天（周六）。但也可以带上数字，7L 表示每个月的最后一个周六 </li>
<li>W: 表示月份离工作日（周一到周五）最接近的 Day of month。例如 1W，如果月份 1 号是周六，那么对应的就是 3 号，再例如 2W，如果月份 2 号是周六 ，则对应的是 1 号。</li>
<li>#: y#x 只能用在 Day of week上，表示每月的第 x 个周 y (周7表示周六，周1表示周天)</li>
</ol>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 每年的母亲节早上7点</span><br><span class="line">0 0 7 ? 5 1#2</span><br><span class="line">// 每年的父亲节早上7点</span><br><span class="line">0 0 7 ? 6 1#3</span><br><span class="line">// 每年元旦的早上7点</span><br><span class="line">0 0 7 1 1 ?</span><br><span class="line">// 每周一早上9点半</span><br><span class="line">0 30 9 ? * 1</span><br><span class="line">// 每周五下午6点</span><br><span class="line">0 0 6 ? * 5</span><br><span class="line">// 每个月的最后一个非周末的下午6点</span><br><span class="line">0 0 6 ? * WL</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>通过Github Actions部署你的Hexo博客</title>
    <url>/2022/07/12/deploy-hexo/</url>
    <content><![CDATA[<p>最近被生活中的琐事所困扰，实在有些迷茫，因此又双叒叕的骚动了想要记录点事情的冲动，思来想去，出于对nodejs相关技术栈的亲切感，选了hexo。<span id="more"></span></p>
<h2 id="使用hexo-d进行部署"><a href="#使用hexo-d进行部署" class="headerlink" title="使用hexo d进行部署"></a>使用hexo d进行部署</h2><ol>
<li><p>增加 <code>hexo-deployer-git</code> 依赖，在_config.yaml文件里配置 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git #提交类型git</span><br><span class="line">    repo: git@github.com:xxx/xxx.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加部署命令：<code> &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;</code>,执行 <code>npm run deploy</code>,然后打开你的github page即可看到你的博客啦。</p>
</li>
</ol>
<p>这些其实官网中都有相关的介绍了，但是有个问题，打开你的github仓库能够看到，仓库中的代码实际上是编译后的静态js html css文件，这就导致你需要一个单独的仓库去管理你的源码。</p>
<h2 id="使用github-action进行部署"><a href="#使用github-action进行部署" class="headerlink" title="使用github action进行部署"></a>使用github action进行部署</h2><p>虽然其实严格来说上述的步骤也不麻烦，只是需要每次执行push前做一次npm run deploy，但是在阅读文档时，看到介绍，可以采用github action来做部署，因此果断尝试一下</p>
<ol>
<li>执行 <code>ssh-keygen -t rsa -C &quot;email&quot;</code>,不要默认命名，输入类似  xxx_blog_deploy  的名字方便你后续找到对应的 ssh key</li>
<li>在你的github page仓库的Settings&#x2F;Deploy keys 增加xxx_blog_deploy.pub的内容，并注意要基于write access</li>
<li>在你的blog source仓库的Settings&#x2F;Secrets 仓库增加xxx_blog_deploy 的内容</li>
<li>在你的source的.github&#x2F;workflows 文件夹下增加 xxx.yml (我用的pnpm, npm的缓存方式可以参考<code>sma11black/hexo-action</code>示例)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Deploy</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  - push</span><br><span class="line">  - pull_request</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    name: A job to deploy hexo blog.</span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        node: [ &#x27;12&#x27;, &#x27;14&#x27;, &#x27;16&#x27; ]</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout</span><br><span class="line">      uses: actions/checkout@v2</span><br><span class="line">      with:</span><br><span class="line">        submodules: true # Checkout private submodules(themes or something else).</span><br><span class="line">    - name: Setup node</span><br><span class="line">      uses: actions/setup-node@v2</span><br><span class="line">      with:</span><br><span class="line">        node-version: $&#123;&#123; matrix.node &#125;&#125;</span><br><span class="line">    - name: Cache pnpm modules</span><br><span class="line">      uses: actions/cache@v2</span><br><span class="line">      with:</span><br><span class="line">        path: ~/.pnpm-store</span><br><span class="line">        key: $&#123;&#123; runner.os &#125;&#125;-$&#123;&#123; hashFiles(&#x27;**/pnpm-lock.yaml&#x27;) &#125;&#125;</span><br><span class="line">        restore-keys: |</span><br><span class="line">          $&#123;&#123; runner.os &#125;&#125;-</span><br><span class="line">    - uses: pnpm/action-setup@v2.0.1</span><br><span class="line">      with:</span><br><span class="line">        version: 6.0.2</span><br><span class="line">        run_install: true</span><br><span class="line">    </span><br><span class="line">    # Deploy hexo blog website.</span><br><span class="line">    - name: Deploy</span><br><span class="line">      id: deploy</span><br><span class="line">      uses: sma11black/hexo-action@v1.0.3</span><br><span class="line">      with:</span><br><span class="line">        deploy_key: $&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;</span><br><span class="line">        user_name: xxx  # (or delete this input setting to use bot account)</span><br><span class="line">        user_email: xxx@xxx.com  # (or delete this input setting to use bot account)</span><br><span class="line">        commit_msg: $&#123;&#123; github.event.head_commit.message &#125;&#125;  # (or delete this input setting to use hexo default settings)</span><br><span class="line">    # Use the output from the `deploy` step(use for test action)</span><br><span class="line">    - name: Get the output</span><br><span class="line">      run: |</span><br><span class="line">        echo &quot;$&#123;&#123; steps.deploy.outputs.notify &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></li>
<li>每次git push后会自动触发github action 帮你生成静态文件，并且将静态文件推到 github page仓库了。</li>
</ol>
<p>希望这次是个好的开始，希望能坚持输出博客~</p>
]]></content>
  </entry>
  <entry>
    <title>前端性能量化</title>
    <url>/2022/07/12/frontend-performance/</url>
    <content><![CDATA[<p>工作过程中，经常需要表现下自己的工作成果，但是所谓空口无凭，数据才是最直观的，刚好，贴心的浏览器提供了 performance API <span id="more"></span></p>
<h2 id="performance-memory"><a href="#performance-memory" class="headerlink" title="performance.memory"></a>performance.memory</h2><p>能够通过 performance.memory 获得以下数据 （都以字节计算</p>
<ol>
<li><code>usedJSHeapSize</code> : 当前 JS 堆活跃段（segment）的体积 The currently active segment of JS heap, in bytes.</li>
<li><code>totalJSHeapSize</code> : 已分配的堆体积 The total allocated heap size, in bytes.</li>
<li><code>jsHeapSizeLimit</code> : 上下文内可用堆的最大体积 The maximum size of the heap, in bytes, that is available to the context</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>git 小知识记录</title>
    <url>/2022/07/12/git-tips/</url>
    <content><![CDATA[<p>最近用 git 时遇到几次修改文件名大小写不生效的问题，很是恶心，突发奇想，用 blog 记录一下那些碰到的问题<span id="more"></span></p>
<h2 id="在-git-中修改文件名大小写"><a href="#在-git-中修改文件名大小写" class="headerlink" title="在 git 中修改文件名大小写"></a>在 git 中修改文件名大小写</h2><ol>
<li>如果是修改文件名，可以用 git mv</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv -f yOuRfIlEnAmE yourfilename</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改 gitconfig</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config core.ignorecase false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- in ~/.gitconfig --&gt;</span><br><span class="line">[core]</span><br><span class="line">	ignorecase = false</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除 git 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cached xxxx</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>powershell 学习</title>
    <url>/2022/07/12/powershell-study/</url>
    <content><![CDATA[<p>本来作为一名前端人员，用 nodejs 实现脚本的想法是自然的，然而实际使用过程中，发现还是怀念在 oh my zh 里面畅快使用命令的日子，但是工作的开发环境是 Windows ，所幸 powershell 脚本其实也挺好用，于是也记录一些对于 powershell 的学习 <span id="more"></span></p>
<h2 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h2><p>首先在 powershell 执行 <code>Code $PROFILE</code> （Code 会全局的打开 VSCode 编辑器，可能需要配置环境变量，可自行选择文本编辑器）,然后保存文件，这样能够迅速的创建一个脚本，会在每次启动 powershell 时执行。</p>
<h2 id="open-命令"><a href="#open-命令" class="headerlink" title="open 命令"></a>open 命令</h2><p>open . 在 omz 中能迅速的打开当前文件夹，这对我来说算是非常常用的一个命令，而在 powershell 中对应的命令是 ii, 因此可以实现一个 open 方法（对于有 Typescript 经验的开发人员来说，这实在太过熟悉。。。以至于我甚至没有阅读过任何 ps 脚本文档，只是仿照着其他脚本就实现了一个简单的 open 命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">([string]<span class="variable">$path</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ii</span> <span class="string">&quot;<span class="variable">$path</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>读取和设置环境变量，这里直接在机器级别进行，方便后续账号切换后，配置依然生效。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEnv</span><span class="params">([string]<span class="variable">$key</span>)</span></span> &#123;</span><br><span class="line">    [<span class="type">Environment</span>]::GetEnvironmentVariable(<span class="string">&quot;<span class="variable">$key</span>&quot;</span>, [<span class="type">EnvironmentVariableTarget</span>]::Machine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只添加不修改，方便回退</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setEnv</span><span class="params">([string]<span class="variable">$key</span>,[string]<span class="variable">$value</span>)</span></span> &#123;</span><br><span class="line">    [<span class="type">Environment</span>]::SetEnvironmentVariable(</span><br><span class="line">        <span class="string">&quot;<span class="variable">$key</span>&quot;</span>,</span><br><span class="line">        [<span class="type">Environment</span>]::GetEnvironmentVariable(<span class="string">&quot;<span class="variable">$key</span>&quot;</span>, [<span class="type">EnvironmentVariableTarget</span>]::Machine) + <span class="string">&quot;;<span class="variable">$value</span>&quot;</span>,</span><br><span class="line">        [<span class="type">EnvironmentVariableTarget</span>]::Machine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为 set 的时候只做了添加，为了防止重复，这里清理重复的 path</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="variable">$CurrentPath</span> = [<span class="type">Environment</span>]::GetEnvironmentVariable(<span class="string">&#x27;Path&#x27;</span>,<span class="string">&#x27;Machine&#x27;</span>)</span><br><span class="line">    <span class="variable">$SplittedPath</span> = <span class="variable">$CurrentPath</span> <span class="operator">-split</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    <span class="variable">$CleanedPath</span> = <span class="variable">$SplittedPath</span> | <span class="built_in">Sort-Object</span> <span class="literal">-Unique</span></span><br><span class="line">    <span class="variable">$NewPath</span> = <span class="variable">$CleanedPath</span> <span class="operator">-join</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    [<span class="type">Environment</span>]::SetEnvironmentVariable(<span class="string">&#x27;Path&#x27;</span>, <span class="variable">$NewPath</span>,<span class="string">&#x27;Machine&#x27;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;complete clean&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
