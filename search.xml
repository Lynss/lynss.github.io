<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cron 表达式学习</title>
    <url>/2023/02/02/cron-study/</url>
    <content><![CDATA[<p>之前在做一些定时处理的时候经常接触到了Cron表达式，但每次都是泛泛的了解了下，最近又有了定时任务相关的一些需求和想法，因此这里尝试系统的学习和了解一下 <span id="more"></span></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Required</th>
<th>Allowed Values</th>
<th>Allowed Special Characters</th>
</tr>
</thead>
<tbody><tr>
<td>Seconds</td>
<td>Y</td>
<td>0-59</td>
<td>, - * &#x2F;</td>
</tr>
<tr>
<td>Minutes</td>
<td>Y</td>
<td>0-59</td>
<td>, - * &#x2F;</td>
</tr>
<tr>
<td>Hours</td>
<td>Y</td>
<td>0-23</td>
<td>, - * &#x2F;</td>
</tr>
<tr>
<td>Day of month</td>
<td>Y</td>
<td>1-31</td>
<td>, - * ? &#x2F; L W</td>
</tr>
<tr>
<td>Month</td>
<td>Y</td>
<td>0-11 or JAN-DEC</td>
<td>, - * &#x2F;</td>
</tr>
<tr>
<td>Day of week</td>
<td>Y</td>
<td>1-7 or SUN-SAT</td>
<td>, - * ? &#x2F; L #</td>
</tr>
<tr>
<td>Year</td>
<td>N</td>
<td>empty or 1970-2099</td>
<td>, - * &#x2F;</td>
</tr>
</tbody></table>
<h2 id="和"><a href="#和" class="headerlink" title="* 和 ?"></a>* 和 ?</h2><p>这里值得一提的是 * 和 ? 的区别</p>
<p>*: 很好理解，代表所有的，例如所有时刻的每一秒就是 <code>* * * * * ? </code> </p>
<p>?: 代表不受控制的，只能由 Day of week 和 Day of month使用，因为二者是互斥的，例如：</p>
<p>当你指定 Day of week 为周 1 时，对应的 Day of month 是 ?, 随意几号<br>当你指定 Day of month 为每月 1 号时，对应的Day of week 就需要为 ?, 随意周几</p>
<h2 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h2><p>Day of week里 0代指的是周日</p>
<h2 id="特殊字符含义"><a href="#特殊字符含义" class="headerlink" title="特殊字符含义"></a>特殊字符含义</h2><p>为了方便，都用数字来表示。</p>
<ol>
<li>,: 可以理解为一个数组， 例如 1,3,10 * * * * ? 代表每分钟的第 1 秒、第 3 秒、第 10 秒执行</li>
<li>-: 表示连续的范围，可以理解为数组的简写 1-6 对应的数组完全体写法就是 1,2,3,4,5,6</li>
<li>*: 匹配所有值，对于秒就是 0-59 ，对于月就是 0-11</li>
<li>?: 无法控制的，也不需要在意的，例如当我在意的是每周1，我就无法在意或控制周一对应的是每月的1号</li>
<li>&#x2F;: 表示step,例如在 Day of month 上 x&#x2F;y 完整形式可以写成x-31&#x2F;y (有的月份30天，有的31天，可能不一样。以此类推，如果是在秒上，就是 x-59&#x2F;y) ，表示的意思就是从 每月x号开始一直到31号，每隔y天执行一次</li>
<li>L: 表示最后的,只能在 Day of month 和Day of week 上使用，在Day of month 上表示每月的最后一天（闰年的2月最后一天是28号），在 Day of week 上表示每周的最后一个天（周六）。但也可以带上数字，7L 表示每个月的最后一个周六 </li>
<li>W: 表示月份离工作日（周一到周五）最接近的 Day of month。例如 1W，如果月份 1 号是周六，那么对应的就是 3 号，再例如 2W，如果月份 2 号是周六 ，则对应的是 1 号。</li>
<li>#: y#x 只能用在 Day of week上，表示每月的第 x 个周 y (周7表示周六，周1表示周天)</li>
</ol>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 每年的母亲节早上7点</span><br><span class="line">0 0 7 ? 5 1#2</span><br><span class="line">// 每年的父亲节早上7点</span><br><span class="line">0 0 7 ? 6 1#3</span><br><span class="line">// 每年元旦的早上7点</span><br><span class="line">0 0 7 1 1 ?</span><br><span class="line">// 每周一早上9点半</span><br><span class="line">0 30 9 ? * 1</span><br><span class="line">// 每周五下午6点</span><br><span class="line">0 0 6 ? * 5</span><br><span class="line">// 每个月的最后一个非周末的下午6点</span><br><span class="line">0 0 6 ? * WL</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>通过Github Actions部署你的Hexo博客</title>
    <url>/2023/02/02/deploy-hexo/</url>
    <content><![CDATA[<p>最近被生活中的琐事所困扰，实在有些迷茫，因此又双叒叕的骚动了想要记录点事情的冲动，思来想去，出于对nodejs相关技术栈的亲切感，选了hexo。<span id="more"></span></p>
<h2 id="使用hexo-d进行部署"><a href="#使用hexo-d进行部署" class="headerlink" title="使用hexo d进行部署"></a>使用hexo d进行部署</h2><ol>
<li><p>增加 <code>hexo-deployer-git</code> 依赖，在_config.yaml文件里配置 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git #提交类型git</span><br><span class="line">    repo: git@github.com:xxx/xxx.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加部署命令：<code> &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;</code>,执行 <code>npm run deploy</code>,然后打开你的github page即可看到你的博客啦。</p>
</li>
</ol>
<p>这些其实官网中都有相关的介绍了，但是有个问题，打开你的github仓库能够看到，仓库中的代码实际上是编译后的静态js html css文件，这就导致你需要一个单独的仓库去管理你的源码。</p>
<h2 id="使用github-action进行部署"><a href="#使用github-action进行部署" class="headerlink" title="使用github action进行部署"></a>使用github action进行部署</h2><p>虽然其实严格来说上述的步骤也不麻烦，只是需要每次执行push前做一次npm run deploy，但是在阅读文档时，看到介绍，可以采用github action来做部署，因此果断尝试一下</p>
<ol>
<li>执行 <code>ssh-keygen -t rsa -C &quot;email&quot;</code>,不要默认命名，输入类似  xxx_blog_deploy  的名字方便你后续找到对应的 ssh key</li>
<li>在你的github page仓库的Settings&#x2F;Deploy keys 增加xxx_blog_deploy.pub的内容，并注意要基于write access</li>
<li>在你的blog source仓库的Settings&#x2F;Secrets 仓库增加xxx_blog_deploy 的内容</li>
<li>在你的source的.github&#x2F;workflows 文件夹下增加 xxx.yml (我用的pnpm, npm的缓存方式可以参考<code>sma11black/hexo-action</code>示例)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Deploy</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  - push</span><br><span class="line">  - pull_request</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    name: A job to deploy hexo blog.</span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        node: [ &#x27;12&#x27;, &#x27;14&#x27;, &#x27;16&#x27; ]</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout</span><br><span class="line">      uses: actions/checkout@v2</span><br><span class="line">      with:</span><br><span class="line">        submodules: true # Checkout private submodules(themes or something else).</span><br><span class="line">    - name: Setup node</span><br><span class="line">      uses: actions/setup-node@v2</span><br><span class="line">      with:</span><br><span class="line">        node-version: $&#123;&#123; matrix.node &#125;&#125;</span><br><span class="line">    - name: Cache pnpm modules</span><br><span class="line">      uses: actions/cache@v2</span><br><span class="line">      with:</span><br><span class="line">        path: ~/.pnpm-store</span><br><span class="line">        key: $&#123;&#123; runner.os &#125;&#125;-$&#123;&#123; hashFiles(&#x27;**/pnpm-lock.yaml&#x27;) &#125;&#125;</span><br><span class="line">        restore-keys: |</span><br><span class="line">          $&#123;&#123; runner.os &#125;&#125;-</span><br><span class="line">    - uses: pnpm/action-setup@v2.0.1</span><br><span class="line">      with:</span><br><span class="line">        version: 6.0.2</span><br><span class="line">        run_install: true</span><br><span class="line">    </span><br><span class="line">    # Deploy hexo blog website.</span><br><span class="line">    - name: Deploy</span><br><span class="line">      id: deploy</span><br><span class="line">      uses: sma11black/hexo-action@v1.0.3</span><br><span class="line">      with:</span><br><span class="line">        deploy_key: $&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;</span><br><span class="line">        user_name: xxx  # (or delete this input setting to use bot account)</span><br><span class="line">        user_email: xxx@xxx.com  # (or delete this input setting to use bot account)</span><br><span class="line">        commit_msg: $&#123;&#123; github.event.head_commit.message &#125;&#125;  # (or delete this input setting to use hexo default settings)</span><br><span class="line">    # Use the output from the `deploy` step(use for test action)</span><br><span class="line">    - name: Get the output</span><br><span class="line">      run: |</span><br><span class="line">        echo &quot;$&#123;&#123; steps.deploy.outputs.notify &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></li>
<li>每次git push后会自动触发github action 帮你生成静态文件，并且将静态文件推到 github page仓库了。</li>
</ol>
<p>希望这次是个好的开始，希望能坚持输出博客~</p>
]]></content>
  </entry>
  <entry>
    <title>前端性能量化</title>
    <url>/2023/02/02/frontend-performance/</url>
    <content><![CDATA[<p>工作过程中，经常需要表现下自己的工作成果，但是所谓空口无凭，数据才是最直观的，刚好，贴心的浏览器提供了 performance API <span id="more"></span></p>
<h2 id="performance-memory"><a href="#performance-memory" class="headerlink" title="performance.memory"></a>performance.memory</h2><p>能够通过 performance.memory 获得以下数据 （都以字节计算</p>
<ol>
<li><code>usedJSHeapSize</code> : 当前 JS 堆活跃段（segment）的体积 The currently active segment of JS heap, in bytes.</li>
<li><code>totalJSHeapSize</code> : 已分配的堆体积 The total allocated heap size, in bytes.</li>
<li><code>jsHeapSizeLimit</code> : 上下文内可用堆的最大体积 The maximum size of the heap, in bytes, that is available to the context</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>git 小知识记录</title>
    <url>/2023/02/02/git-tips/</url>
    <content><![CDATA[<p>最近用 git 时遇到几次修改文件名大小写不生效的问题，很是恶心，突发奇想，用 blog 记录一下那些碰到的问题<span id="more"></span></p>
<h2 id="在-git-中修改文件名大小写"><a href="#在-git-中修改文件名大小写" class="headerlink" title="在 git 中修改文件名大小写"></a>在 git 中修改文件名大小写</h2><ol>
<li>如果是修改文件名，可以用 git mv</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv -f yOuRfIlEnAmE yourfilename</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改 gitconfig</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config core.ignorecase false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- in ~/.gitconfig --&gt;</span><br><span class="line">[core]</span><br><span class="line">	ignorecase = false</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除 git 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cached xxxx</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>powershell 学习</title>
    <url>/2023/02/02/powershell-study/</url>
    <content><![CDATA[<p>本来作为一名前端人员，用 nodejs 实现脚本的想法是自然的，然而实际使用过程中，发现还是怀念在 oh my zh 里面畅快使用命令的日子，但是工作的开发环境是 Windows ，所幸 powershell 脚本其实也挺好用，于是也记录一些对于 powershell 的学习 <span id="more"></span></p>
<h2 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h2><p>首先在 powershell 执行 <code>Code $PROFILE</code> （Code 会全局的打开 VSCode 编辑器，可能需要配置环境变量，可自行选择文本编辑器）,然后保存文件，这样能够迅速的创建一个脚本，会在每次启动 powershell 时执行。</p>
<h2 id="open-命令"><a href="#open-命令" class="headerlink" title="open 命令"></a>open 命令</h2><p>open . 在 omz 中能迅速的打开当前文件夹，这对我来说算是非常常用的一个命令，而在 powershell 中对应的命令是 ii, 因此可以实现一个 open 方法（对于有 Typescript 经验的开发人员来说，这实在太过熟悉。。。以至于我甚至没有阅读过任何 ps 脚本文档，只是仿照着其他脚本就实现了一个简单的 open 命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">([string]<span class="variable">$path</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ii</span> <span class="string">&quot;<span class="variable">$path</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>读取和设置环境变量，这里直接在机器级别进行，方便后续账号切换后，配置依然生效。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEnv</span><span class="params">([string]<span class="variable">$key</span>)</span></span> &#123;</span><br><span class="line">    [<span class="type">Environment</span>]::GetEnvironmentVariable(<span class="string">&quot;<span class="variable">$key</span>&quot;</span>, [<span class="type">EnvironmentVariableTarget</span>]::Machine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只添加不修改，方便回退</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setEnv</span><span class="params">([string]<span class="variable">$key</span>,[string]<span class="variable">$value</span>)</span></span> &#123;</span><br><span class="line">    [<span class="type">Environment</span>]::SetEnvironmentVariable(</span><br><span class="line">        <span class="string">&quot;<span class="variable">$key</span>&quot;</span>,</span><br><span class="line">        [<span class="type">Environment</span>]::GetEnvironmentVariable(<span class="string">&quot;<span class="variable">$key</span>&quot;</span>, [<span class="type">EnvironmentVariableTarget</span>]::Machine) + <span class="string">&quot;;<span class="variable">$value</span>&quot;</span>,</span><br><span class="line">        [<span class="type">EnvironmentVariableTarget</span>]::Machine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为 set 的时候只做了添加，为了防止重复，这里清理重复的 path</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="variable">$CurrentPath</span> = [<span class="type">Environment</span>]::GetEnvironmentVariable(<span class="string">&#x27;Path&#x27;</span>,<span class="string">&#x27;Machine&#x27;</span>)</span><br><span class="line">    <span class="variable">$SplittedPath</span> = <span class="variable">$CurrentPath</span> <span class="operator">-split</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    <span class="variable">$CleanedPath</span> = <span class="variable">$SplittedPath</span> | <span class="built_in">Sort-Object</span> <span class="literal">-Unique</span></span><br><span class="line">    <span class="variable">$NewPath</span> = <span class="variable">$CleanedPath</span> <span class="operator">-join</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    [<span class="type">Environment</span>]::SetEnvironmentVariable(<span class="string">&#x27;Path&#x27;</span>, <span class="variable">$NewPath</span>,<span class="string">&#x27;Machine&#x27;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;complete clean&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>powershell 本身提供了 remove-item 命令，这里做一个简单的映射到 rm 即可，虽然没有 -rf，但可以通过 -Recursive 和 -Force 来代替，并且即使没有传入 Flag ，也会有一个友好的交互提示如何进行下一步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function rm([string]$path)&#123;</span><br><span class="line">    remove-item $path</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>VSCode 配置远程登录免密码.md</title>
    <url>/2023/02/02/vscode%20%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%85%8D%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>最近，发现 vscode 的远程开发能力很棒，这里记录一个免密登录的方法，避免每次链接远程服务器都需要使用密码 <span id="more"></span></p>
<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><ol>
<li>本地安装好了 ssh 客户端</li>
<li>vscode 安装了 remote development 相关的远程插件</li>
</ol>
<h2 id="配置秘钥"><a href="#配置秘钥" class="headerlink" title="配置秘钥"></a>配置秘钥</h2><ol>
<li>执行 ssh-keygen， 这里建议给生成的文件配置一个单独的名称，例如<code>id_rsa.vultr</code><br><img src="/images/posts/id_rsa.vultr.png"></li>
<li>执行 <code>cat ~/.ssh/id_rsa.vultr.pub</code>, 将内容复制下来</li>
<li>在远程服务器上，打开 <code>~/.ssh/authorized_keys</code> 文件，将刚刚的内容贴上去</li>
<li>在 vscode 远程资源管理中，点击右上角配置文件<br><img src="/images/posts/2.png"></li>
<li>在配置文件中配置 IdentiyFile 路径<br><img src="/images/posts/3.png"></li>
</ol>
<p>这时，在尝试登录远程服务器就不再需要密码了</p>
]]></content>
  </entry>
  <entry>
    <title>安装和初始化 PostgreSQL  数据库</title>
    <url>/2023/02/02/%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%20PostgreSQL%20%20%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>近期，想在自己的服务器上进行生产环境的搭建，数据库选用的是 PostgreSQL  这里记录一下数据库的搭建流程 <span id="more"></span></p>
<h2 id="PostgreSQL-下载"><a href="#PostgreSQL-下载" class="headerlink" title="PostgreSQL 下载"></a>PostgreSQL 下载</h2><p>参考<a href="https://www.postgresql.org/download/">官网</a>, 在服务器上执行 uname -a ，能够看到是 Debian 的系统，他是自带 postgresql 的<br><img src="/images/posts/2023-01-27-10-11-33.png"><br>因此执行 <code>sudo apt-get install postgresql</code> 即可</p>
<h2 id="PostgreSQL-初始化配置"><a href="#PostgreSQL-初始化配置" class="headerlink" title="PostgreSQL 初始化配置"></a>PostgreSQL 初始化配置</h2><p>初次安装后，会默认生成一个名为 postgres 的数据库和数据库用户，并且会同时生成一个名为 postgres 的 linux 系统用户。由于默认的 postgres 数据库用户没有密码，我们需要先为其配置对应的密码，</p>
<ol>
<li>首先切换到 postgres 用户 <code>sudo su - postgres</code></li>
<li>登录 postgres 控制台 <code>psql</code></li>
<li>执行 <code>\password postgres</code> 命令设置密码</li>
</ol>
<p>现在，我需要初始化一个名为 xxx 的数据库和用户,紧接着刚刚的步骤</p>
<ol>
<li>创建数据库用户 <code> CREATE USER xxx WITH PASSWORD &#39;xxx&#39;</code>;</li>
<li>创建数据库 <code>CREATE DATABASE xxx OWNER xxx;</code></li>
<li>对数据库 xxx 的所有权限授予 xxx <code>GRANT ALL PRIVILEGES ON DATABASE xxx to xxx;</code></li>
<li>\q 退出 postgres 控制台</li>
<li>使用新建的数据库用户 xxx 来登录 postgres 控制台 <code>psql -U xxx -d xxx -h 127.0.0.1 -p 5432</code></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>服务器安装和初始化 Redis</title>
    <url>/2023/02/02/%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%20Redis/</url>
    <content><![CDATA[<p>记录一下 Redis 的安装和初始化流程 <span id="more"></span></p>
<h2 id="Redis-下载"><a href="#Redis-下载" class="headerlink" title="Redis 下载"></a>Redis 下载</h2><p>参考<a href="https://redis.io/docs/getting-started/installation/install-redis-on-linux/">官网</a></p>
<ol>
<li>确认服务器是否已经安装了 lsb-release (尝试执行 <code>lsb_release -cs</code> )，如果没有，执行安装 <code>sudo apt install lsb-release</code></li>
<li>按顺序执行如下命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg</span><br><span class="line">echo &quot;deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main&quot; | sudo tee /etc/apt/sources.list.d/redis.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install redis</span><br></pre></td></tr></table></figure>

<h2 id="设置-Redis-密码"><a href="#设置-Redis-密码" class="headerlink" title="设置 Redis 密码"></a>设置 Redis 密码</h2><ol>
<li>打开 redis 配置文件，如上方法安装后，默认的配置文件在 <code>/etc/redis/redis.conf</code> 下</li>
<li>找到 <code>requirepass xxx</code>，取消注释，修改为自己希望的密码</li>
<li>重启 redis-server <code>service redis-server restart</code>.</li>
<li>执行 <code>redis-cli -a xxx</code>完成客户端认证</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>英语学习</title>
    <url>/2023/02/02/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>记录英语学习的一些知识点 <span id="more"></span></p>
<h2 id="英语的词性（词类）-（word-classes）（parts-of-speech"><a href="#英语的词性（词类）-（word-classes）（parts-of-speech" class="headerlink" title="英语的词性（词类） （word classes）（parts of speech)"></a>英语的词性（词类） （word classes）（parts of speech)</h2><p>目前网上存在两种说法，其中中文搜索的结果说英语有 10 种词类，但是英文搜索的结果是 9 种（没有归类数词），这里采用英文搜索的结果。</p>
<p>其中，有四种主要的词类</p>
<ol>
<li>名词 (Noun)</li>
<li>动词 (Verb)</li>
<li>形容词 (Adjective)</li>
<li>副词 (Adverb)</li>
</ol>
<p>其它的词类包括</p>
<ol start="5">
<li>代词 Pronoun (e.g. I, you, me, we, mine, someone, he, she)</li>
<li>介词 Preposition (e.g. at, in, on, across, behind, for)</li>
<li>连词 Conjunction (e.g. and, but, when, if, because)</li>
<li>限定词 Determiner (e.g. a, the, an, this, etc.)</li>
<li>感叹词 Exclamation or Interjection (e.g. oh, ah, wow, ouch)</li>
</ol>
<h2 id="英语的句子成分（Sentence-structure）"><a href="#英语的句子成分（Sentence-structure）" class="headerlink" title="英语的句子成分（Sentence structure）"></a>英语的句子成分（Sentence structure）</h2><ol>
<li>主语（subject）</li>
</ol>
<p>一般作为 “动作的发起者” svo 或者 “表述的对象” svp<br><img src="/images/posts/v2-4c361186e04cd175608c1c3020489fa5_720w.webp"><br><img src="/images/posts/v2-981d99e00cac1e0a795b8abee4a5688b_720w.webp"></p>
<ol start="2">
<li>谓语（predicate）</li>
</ol>
<p>对主语动作状态或特征的陈述或说明，指出“做什么（what to do）” “是什么（what is this）”</p>
<p><img src="/images/posts/v2-77b3614ab60fd115583bcd7cde117cb6_720w.webp"></p>
<ol start="3">
<li>表语（predicative）</li>
</ol>
<p>用来说明主语的身份、性质、品性、特征和状态等。<br><img src="/images/posts/v2-a6b4f9b175c35b096e4a9415fb6af259_720w.webp"></p>
<ol start="4">
<li>宾语（object）</li>
</ol>
<p>一般用在及物动词的后面，表示行为动作所涉及的对象。宾语跟主语是相对的，只要能做主语的成分都能做宾语。<br><img src="/images/posts/v2-0a7ace22b41d1af473e09f2425c8651d_720w.webp"></p>
<ol start="5">
<li>定语（attribute）</li>
</ol>
<p>用来修饰、限定、说明名词或代词的品质与特征的。</p>
<p><img src="/images/posts/v2-8f289ce6c4461b0bb7109dc0a760d72b_720w.webp"></p>
<ol start="6">
<li>状语(adverbial)</li>
</ol>
<p>主要用来修饰谓语或句子。包括：时间、地点、原因、结果、目的、方式、条件、让步、比较、伴随。<br><img src="/images/posts/v2-86c5ed08009eca592f5ac867e071bc19_720w.webp"></p>
<ol start="7">
<li>补语（complement）</li>
</ol>
<p>补充说明主语或宾语，使其意义更完整，在句法上是不可或缺的一部分。</p>
<p>主语补语<br><img src="/images/posts/v2-2a5669cbe5a878dfda054d202c463b29_720w.webp"></p>
<p>宾语补语<br><img src="/images/posts/v2-8e61f0b289b054d31e22ab86c6d9343f_720w.webp"></p>
<ol start="8">
<li>同位语</li>
</ol>
<p>用来补充说明名词，代词.</p>
<p><img src="/images/posts/v2-c5c9da5dc1572a12f255408ba4905e90_720w.webp"></p>
<h2 id="英语的基本句式"><a href="#英语的基本句式" class="headerlink" title="英语的基本句式"></a>英语的基本句式</h2><ol>
<li>S V （主＋谓）</li>
<li>S V P （主＋系＋表）</li>
<li>S V O （主＋谓＋宾）</li>
<li>S V O O（主＋谓＋间宾＋直宾）</li>
<li>S V O C（主＋谓＋宾＋宾补）</li>
</ol>
]]></content>
  </entry>
</search>
